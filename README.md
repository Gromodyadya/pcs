ПЗ№5, Лылин Александр Антонович, ЭФБО-09-23

Цели:
Научиться отображать коллекции данных с помощью ListView.builder.
Освоить базовую навигацию Navigator.push / Navigator.pop и передачу данных через конструктор.
Научиться добавлять, редактировать и удалять элементы списка без внешних пакетов и сложных архитектур.

Шаг 1: Проектирование структуры и подготовка проекта
Перед написанием кода я определил базовую архитектуру приложения. Чтобы избежать "спагетти-кода" в одном файле, я сразу разделил логику на несколько частей:
Модель данных (lib/models/note.dart): Класс Note, который описывает структуру заметки. Я сделал его иммутабельным (с final полями), что является хорошей практикой и помогает избежать случайных изменений данных.
Экран списка (lib/main.dart): Главный экран, отвечающий за отображение всех заметок и общую навигацию.
Экран редактирования (lib/edit_note_page.dart): Изолированный виджет-форма, который ничего не знает о списке и занимается только одной задачей: созданием или редактированием заметки.
Такое разделение позволило сделать код более читаемым, модульным и простым в дальнейшей поддержке.

Шаг 2: Реализация UX-ориентированного удаления
Одной из ключевых задач было сделать удаление заметок удобным и интуитивно понятным. Вместо того чтобы полагаться на один способ, я решил предоставить пользователю два варианта, так как это соответствует современным практикам UX и учитывает разные привычки пользователей.
Файл: lib/main.dart
```dart
return Dismissible(
  key: ValueKey(note.id),
  direction: DismissDirection.endToStart,
  onDismissed: (direction) => _delete(note),
  background: Container(/* ... */),
  child: ListTile(
    // ...
    // Добавляем явную кнопку удаления
    trailing: IconButton(
      icon: const Icon(Icons.delete_outline),
      onPressed: () => _delete(note),
    ),
  ),
);
```
Шаг 3: Реализация динамического поиска с фильтрацией
Чтобы приложение было удобным при большом количестве заметок, я реализовал функцию поиска по заголовку. Это потребовало более сложного управления состоянием, чем простые CRUD-операции.
Файл: lib/main.dart
```dart
// Отдельный список для отображения отфильтрованных заметок
List<Note> _filteredNotes = [];

// Метод, который фильтрует основной список _notes по запросу
void _filterNotes() {
  final query = _searchController.text.toLowerCase();
  setState(() {
    _filteredNotes = _notes.where((note) {
      return note.title.toLowerCase().contains(query);
    }).toList();
  });
}
```

Шаг 4: Управление состоянием и организация кода
Для управления состоянием главного экрана я использовал StatefulWidget и метод setState(). Хотя для более крупных приложений существуют продвинутые подходы (Riverpod, BLoC), для локального состояния одного экрана setState является наиболее подходящим, простым и производительным решением, рекомендованным командой Flutter для таких задач.
Чтобы сделать код метода build более чистым и читаемым, я вынес логику создания AppBar в отдельные приватные методы: _buildAppBar() и _buildSearchAppBar().
Файл: lib/main.dart
```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    // В зависимости от состояния, вызывается нужный метод-билдер
    appBar: _isSearching ? _buildSearchAppBar() : _buildAppBar(),
    body: /* ... */
  );
}
```
![Simple Notes — Личный_ Microsoft_ Edge 2025-10-14 11-24-44](https://github.com/user-attachments/assets/2800d4ed-7943-4687-96ba-96f03eee1079)

Выводы:
Все цели практической работы были успешно достигнуты. Были освоены ключевые механизмы фреймворка: создание производительных списков с помощью ListView.builder и реализация межэкранной навигации с передачей данных. В приложении реализован полный цикл CRUD-операций, а пользовательский интерфейс дополнен функциями поиска, удаления свайпом и по кнопке.
Основная сложность возникла при реализации поиска. Эта задача потребовала более детального управления состоянием, а именно — использования отдельного списка для отфильтрованных данных, чтобы избежать потери исходной информации и обеспечить корректное обновление интерфейса после CRUD-операций.
